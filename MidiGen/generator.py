# -*- coding: utf-8 -*-
"""
Created on Thursday April 28th 17:20:42 2022

@author: Skuldur, Daniel Swift (das82)
"""

import tensorflow as tf
import numpy
import pickle
import glob
import music21
import mid_manipulator
from music21 import instrument, note, stream, chord
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Dropout
from keras.layers import LSTM
from keras.layers import BatchNormalization as BatchNorm
from keras.layers import Activation

class Generator:
    def __init__(self, midi, sequence_length, gen_length):
        self.midi = midi
        self.sequence_length = sequence_length
        self.gen_length = gen_length
        
    def generate(self):
        """ Generate a piano midi file """
        #load the notes used to train the model
        with open('notes', 'rb') as filepath:
            notes = pickle.load(filepath)
    
        # Get all pitch names
        pitchnames = sorted(set(item for item in notes))
        # Get all pitch names
        n_vocab = len(set(notes))
    
        network_input, normalized_input = self.prepare_sequences(notes, pitchnames, n_vocab)
        model = self.create_network(normalized_input, n_vocab)
        prediction_output = self.generate_notes(model, network_input, pitchnames, n_vocab)
        new_mid = self.create_midi(prediction_output)
        return new_mid
    
    def prepare_sequences(self, notes, pitchnames, n_vocab):
        """ Prepare the sequences used by the Neural Network """
        # map between notes and integers and back
        note_to_int = dict((note, number) for number, note in enumerate(pitchnames))
    
        sequence_length = self.sequence_length
        network_input = []
        output = []
        for i in range(0, len(notes) - sequence_length, 1):
            sequence_in = notes[i:i + sequence_length]
            sequence_out = notes[i + sequence_length]
            network_input.append([note_to_int[char] for char in sequence_in])
            output.append(note_to_int[sequence_out])
    
        n_patterns = len(network_input)
    
        # reshape the input into a format compatible with LSTM layers
        normalized_input = numpy.reshape(network_input, (n_patterns, sequence_length, 1))
        # normalize input
        normalized_input = normalized_input / float(n_vocab)
    
        return (network_input, normalized_input)
    
    def create_network(self, network_input, n_vocab):
        """ create the structure of the neural network """
        model = Sequential()
        model.add(LSTM(128,input_shape=(network_input.shape[1], network_input.shape[2]), #512
               return_sequences=True))

        model.add(Dropout(0.3))
        model.add(LSTM(128, return_sequences=True)) #512
        model.add(Dropout(0.3))
        model.add(LSTM(128))#512
        model.add(Dense(128))#256
        model.add(Dropout(0.3))
        model.add(Dense(n_vocab))
        model.add(Activation('softmax'))
        model.compile(loss='categorical_crossentropy', optimizer='rmsprop')
    
        # Load the weights to each node
        model.load_weights('das82_weights.hdf5')
    
        return model
    
    def generate_notes(self, model, network_input, pitchnames, n_vocab):
        """ Generate notes from the neural network based on a sequence of notes """
        # pick a random sequence from the input as a starting point for the prediction
        start = numpy.random.randint(0, len(network_input)-1)
    
        int_to_note = dict((number, note) for number, note in enumerate(pitchnames))
    
        pattern = network_input[start]
        #pattern = self.midi_to_notes(self.midi)
        prediction_output = []
    
        # generate 500 notes
        for note_index in range(self.gen_length):
            prediction_input = numpy.reshape(pattern, (1, len(pattern), 1))
            prediction_input = prediction_input / float(n_vocab)
    
            prediction = model.predict(prediction_input, verbose=0)
    
            index = numpy.argmax(prediction)
            result = int_to_note[index]
            prediction_output.append(result)
    
            pattern.append(index)
            pattern = pattern[1:len(pattern)]
    
        return prediction_output
    
    def create_midi(self, prediction_output):
        """ convert the output from the prediction to notes and create a midi file
            from the notes """
        offset = 0
        output_notes = []
    
        # create note and chord objects based on the values generated by the model
        for pattern in prediction_output:
            # pattern is a chord
            if ('.' in pattern) or pattern.isdigit():
                notes_in_chord = pattern.split('.')
                notes = []
                for current_note in notes_in_chord:
                    new_note = note.Note(int(current_note))
                    new_note.storedInstrument = instrument.Piano()
                    notes.append(new_note)
                new_chord = chord.Chord(notes)
                new_chord.offset = offset
                output_notes.append(new_chord)
            # pattern is a note
            else:
                new_note = note.Note(pattern)
                new_note.offset = offset
                new_note.storedInstrument = instrument.Piano()
                output_notes.append(new_note)
    
            # increase offset each iteration so that notes do not stack
            offset += 0.5
    
        midi_stream = stream.Stream(output_notes)
        midi_stream.write("midi", fp='midi_gen.mid')
        return 'midi_gen.mid'
           
   
    def midi_to_notes(self, midi):
        note=[]
        midi = music21.converter.parse(midi)
        print("Parsing %s" % midi)
        notes_to_parse = None
        try:
          s2 = instrument.partitionByInstrument(midi)
          notes_to_parse = s2.parts[0].recurse() 
                    
        except: 
          notes_to_parse = midi.flat.notes
          
        for element in notes_to_parse:
          if isinstance(element, note.Note):
            notes.append(str(element.pitch))
          elif isinstance(element, chord.Chord):
            notes.append('.'.join(str(n) for n in element.normalOrder))
        
        # Get all pitch names
        pitchnames = sorted(set(item for item in notes))
        # Get all pitch names
        n_vocab = len(set(notes))
        print(n_vocab)
        network_input, normalized_input = prepare_sequences(notes, pitchnames, n_vocab)
        return network_input 
    
    def get_midi_info(self):
        midi = self.midi
        mid_manip = mid_manipulator.MidiInfo(midi)
        print(mid_manip.get_file_info())
        mid_manip.get_track_messages(1)
        
        
#file = "tremfals.mid"
#generator = Generator(file, 50, 500)
#generator.generate()        

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        